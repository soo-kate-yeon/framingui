/**
 * Screen Templates Generator
 * Template generation for different framework types
 *
 * @module screen/templates
 */

import type { ArchetypeName } from "./schemas.js";

/**
 * Convert kebab-case to PascalCase for component names
 */
export function toPascalCase(str: string): string {
  return str
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}

/**
 * Convert path to component name
 * e.g., "/users/profile" -> "UsersProfile"
 */
export function pathToComponentName(path: string): string {
  return path
    .split("/")
    .filter((segment) => segment.length > 0)
    .map((segment) => toPascalCase(segment))
    .join("");
}

/**
 * Generate Next.js App Router page template
 */
export function generateNextAppTemplate(
  screenName: string,
  intent: string,
  targetPath: string,
  archetype?: ArchetypeName
): string {
  const componentName = toPascalCase(screenName) + "Page";
  const archetypeClass = archetype ? getArchetypeClassName(archetype) : "";

  return `'use client';

/**
 * ${componentName}
 * ${intent}
 *
 * Route: ${targetPath}
 * Generated by Tekton Studio MCP
 */

export default function ${componentName}() {
  return (
    <div className="container mx-auto px-4 py-8${archetypeClass ? ` ${archetypeClass}` : ""}">
      <h1 className="text-2xl font-bold mb-4">${toPascalCase(screenName)}</h1>
      <p className="text-muted-foreground">
        {/* ${intent} */}
      </p>
    </div>
  );
}
`;
}

/**
 * Generate Next.js Pages Router page template
 */
export function generateNextPagesTemplate(
  screenName: string,
  intent: string,
  targetPath: string,
  archetype?: ArchetypeName
): string {
  const componentName = toPascalCase(screenName) + "Page";
  const archetypeClass = archetype ? getArchetypeClassName(archetype) : "";

  return `/**
 * ${componentName}
 * ${intent}
 *
 * Route: ${targetPath}
 * Generated by Tekton Studio MCP
 */

export default function ${componentName}() {
  return (
    <div className="container mx-auto px-4 py-8${archetypeClass ? ` ${archetypeClass}` : ""}">
      <h1 className="text-2xl font-bold mb-4">${toPascalCase(screenName)}</h1>
      <p className="text-muted-foreground">
        {/* ${intent} */}
      </p>
    </div>
  );
}
`;
}

/**
 * Generate Vite page template
 */
export function generateViteTemplate(
  screenName: string,
  intent: string,
  targetPath: string,
  archetype?: ArchetypeName
): string {
  const componentName = toPascalCase(screenName) + "Page";
  const archetypeClass = archetype ? getArchetypeClassName(archetype) : "";

  return `/**
 * ${componentName}
 * ${intent}
 *
 * Route: ${targetPath}
 * Generated by Tekton Studio MCP
 */

export default function ${componentName}() {
  return (
    <div className="container mx-auto px-4 py-8${archetypeClass ? ` ${archetypeClass}` : ""}">
      <h1 className="text-2xl font-bold mb-4">${toPascalCase(screenName)}</h1>
      <p className="text-muted-foreground">
        {/* ${intent} */}
      </p>
    </div>
  );
}
`;
}

/**
 * Get CSS class name for archetype
 */
export function getArchetypeClassName(archetype: ArchetypeName): string {
  const classMap: Record<ArchetypeName, string> = {
    Professional: "archetype-professional",
    Creative: "archetype-creative",
    Minimal: "archetype-minimal",
    Bold: "archetype-bold",
    Warm: "archetype-warm",
    Cool: "archetype-cool",
    "High-Contrast": "archetype-high-contrast",
  };
  return classMap[archetype];
}

/**
 * Generate component code for a given component type
 */
export function generateComponentCode(
  componentType: string,
  props?: Record<string, unknown>
): string {
  const componentName = componentType.replace(/^use/, "");
  const propsString = props
    ? Object.entries(props)
        .map(([key, value]) => {
          if (typeof value === "string") {
            return `${key}="${value}"`;
          }
          return `${key}={${JSON.stringify(value)}}`;
        })
        .join(" ")
    : "";

  return `<${componentName}${propsString ? " " + propsString : ""} />`;
}

/**
 * Generate import statement for a component
 */
export function generateComponentImport(componentType: string): string {
  const componentName = componentType.replace(/^use/, "");
  return `import { ${componentName} } from '@/components/ui/${componentName.toLowerCase()}';`;
}

/**
 * Generate Link component code for Next.js
 */
export function generateLinkCode(targetPath: string, label: string): string {
  return `<Link href="${targetPath}">${label}</Link>`;
}

/**
 * Generate Link import statement
 */
export function generateLinkImport(): string {
  return `import Link from 'next/link';`;
}

/**
 * Apply archetype styles to screen content
 */
export function applyArchetypeToContent(
  content: string,
  archetype: ArchetypeName
): string {
  const archetypeClass = getArchetypeClassName(archetype);

  // Check if archetype class already exists
  if (content.includes(archetypeClass)) {
    return content;
  }

  // Find the main container div className and add archetype class
  // Pattern matches: className="...container..."
  const containerPattern = /(className="[^"]*container[^"]*)">/;
  const match = content.match(containerPattern);

  if (match) {
    // Add archetype class before the closing quote
    const newClassAttr = `${match[1]} ${archetypeClass}">`;
    return content.replace(match[0], newClassAttr);
  }

  return content;
}

/**
 * Insert component into screen content
 */
export function insertComponentIntoContent(
  content: string,
  componentCode: string,
  componentImport: string
): string {
  // Add import at the top (after 'use client' if present)
  let newContent = content;

  // Check if import already exists
  if (!newContent.includes(componentImport)) {
    const useClientMatch = newContent.match(/'use client';?\n?/);
    if (useClientMatch) {
      const insertPos = useClientMatch.index! + useClientMatch[0].length;
      newContent =
        newContent.slice(0, insertPos) +
        "\n" +
        componentImport +
        newContent.slice(insertPos);
    } else {
      newContent = componentImport + "\n" + newContent;
    }
  }

  // Find the closing tag of the main container div and insert component before it
  // Look for </div> that closes the main container
  const returnPattern = /return\s*\(\s*\n?\s*<div[^>]*>[\s\S]*?(<\/div>\s*\);?\s*\})/;
  const match = newContent.match(returnPattern);

  if (match) {
    // Find position to insert component (before the last closing tag pattern)
    const closingPattern = /(\s*<\/div>\s*\);?\s*\}\s*)$/;
    newContent = newContent.replace(
      closingPattern,
      `\n      ${componentCode}\n    </div>\n  );\n}\n`
    );
  }

  return newContent;
}

/**
 * Insert Link into parent page content
 */
export function insertLinkIntoContent(
  content: string,
  targetPath: string,
  label: string
): string {
  // Add Link import if not present
  let newContent = content;
  const linkImport = generateLinkImport();

  if (!newContent.includes("import Link from")) {
    const importMatch = newContent.match(/^(import[\s\S]*?from[^;]+;)/m);
    if (importMatch) {
      const insertPos = importMatch.index! + importMatch[0].length;
      newContent =
        newContent.slice(0, insertPos) +
        "\n" +
        linkImport +
        newContent.slice(insertPos);
    } else {
      newContent = linkImport + "\n" + newContent;
    }
  }

  // Find a good place to insert the link (after the last element in the main container)
  const linkCode = generateLinkCode(targetPath, label);

  // Look for common patterns to insert the link
  const patterns = [
    // After h1 tag
    /(<h1[^>]*>[\s\S]*?<\/h1>)/,
    // After last div within the container
    /(<div[^>]*>[\s\S]*?)(\s*<\/div>\s*\);?\s*\})/,
  ];

  for (const pattern of patterns) {
    const match = newContent.match(pattern);
    if (match) {
      if (pattern === patterns[0]) {
        // Insert after h1
        newContent = newContent.replace(
          match[0],
          match[0] + `\n      ${linkCode}`
        );
      } else {
        // Insert before closing div
        newContent = newContent.replace(
          pattern,
          `$1\n      ${linkCode}\n    $2`
        );
      }
      break;
    }
  }

  return newContent;
}
