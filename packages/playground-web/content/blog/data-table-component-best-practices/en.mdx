---
title: "Data Table Component Best Practices: AI-Powered UX Guide"
description: "Build high-performance data tables with sorting, filtering, pagination, virtualization, and AI-assisted features for modern web applications."
date: "2026-03-01"
author: "FramingUI team"
tags: ["data-table", "component", "ai", "performance", "ux"]
---

# Data Table Component Best Practices: AI-Powered UX Guide

Data tables are the workhorses of enterprise applications. Done poorly, they're slow, confusing, and frustrating. Done well, they enable users to process thousands of rows efficiently.

This guide covers battle-tested patterns for building data tables that scale—from 10 rows to 10,000+.

## Why Data Tables Are Challenging

Tables combine complex interactions:
- **Sorting** (ascending, descending, multi-column)
- **Filtering** (text search, facets, date ranges)
- **Pagination** (infinite scroll, page-based, virtual scrolling)
- **Selection** (single, multiple, range)
- **Actions** (bulk operations, row actions, inline editing)
- **Responsive layout** (mobile, tablet, desktop)

Get any piece wrong, and UX suffers.

## Pattern #1: Virtualization for Large Datasets

Rendering 10,000 DOM nodes kills performance. Virtualization only renders visible rows.

### React Virtual Implementation

```tsx
import { useVirtualizer } from '@tanstack/react-virtual';

interface DataTableProps<T> {
  data: T[];
  columns: Column<T>[];
}

export function VirtualizedTable<T>({ data, columns }: DataTableProps<T>) {
  const parentRef = React.useRef<HTMLDivElement>(null);

  const rowVirtualizer = useVirtualizer({
    count: data.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50, // Row height in pixels
    overscan: 5, // Render 5 extra rows above/below viewport
  });

  return (
    <div
      ref={parentRef}
      className="table-container"
      style={{ height: '600px', overflow: 'auto' }}
    >
      <div
        style={{
          height: `${rowVirtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {rowVirtualizer.getVirtualItems().map((virtualRow) => {
          const row = data[virtualRow.index];
          return (
            <div
              key={virtualRow.index}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: `${virtualRow.size}px`,
                transform: `translateY(${virtualRow.start}px)`,
              }}
            >
              <TableRow row={row} columns={columns} />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

### Performance Impact

- **Without virtualization**: 10,000 rows × 6 columns = 60,000 DOM nodes
- **With virtualization**: ~20 visible rows × 6 columns = 120 DOM nodes
- **Result**: 500× fewer DOM nodes, smooth 60fps scrolling

## Pattern #2: Smart Sorting with Visual Feedback

Users need to know what's sorted and in what direction.

```tsx
import { useState } from 'react';

type SortDirection = 'asc' | 'desc' | null;

interface SortState {
  column: string | null;
  direction: SortDirection;
}

export function SortableTable<T>({ data, columns }: TableProps<T>) {
  const [sort, setSort] = useState<SortState>({ column: null, direction: null });

  const handleSort = (columnId: string) => {
    setSort((prev) => {
      if (prev.column !== columnId) {
        return { column: columnId, direction: 'asc' };
      }
      if (prev.direction === 'asc') {
        return { column: columnId, direction: 'desc' };
      }
      return { column: null, direction: null }; // Clear sort
    });
  };

  const sortedData = React.useMemo(() => {
    if (!sort.column || !sort.direction) return data;

    return [...data].sort((a, b) => {
      const aValue = a[sort.column];
      const bValue = b[sort.column];

      if (aValue === bValue) return 0;

      const comparison = aValue < bValue ? -1 : 1;
      return sort.direction === 'asc' ? comparison : -comparison;
    });
  }, [data, sort]);

  return (
    <table>
      <thead>
        <tr>
          {columns.map((column) => (
            <th key={column.id} onClick={() => handleSort(column.id)}>
              <div className="sortable-header">
                {column.label}
                {sort.column === column.id && (
                  <span className="sort-icon">
                    {sort.direction === 'asc' ? '↑' : '↓'}
                  </span>
                )}
              </div>
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {sortedData.map((row) => (
          <TableRow key={row.id} row={row} columns={columns} />
        ))}
      </tbody>
    </table>
  );
}
```

### Multi-Column Sorting

```tsx
interface MultiSortState {
  column: string;
  direction: 'asc' | 'desc';
}

const [sorts, setSorts] = useState<MultiSortState[]>([]);

const handleMultiSort = (columnId: string, ctrlKey: boolean) => {
  if (!ctrlKey) {
    // Single column sort (replace existing)
    setSorts([{ column: columnId, direction: 'asc' }]);
    return;
  }

  // Multi-column sort (add/toggle)
  setSorts((prev) => {
    const existing = prev.find((s) => s.column === columnId);
    if (!existing) {
      return [...prev, { column: columnId, direction: 'asc' }];
    }
    if (existing.direction === 'asc') {
      return prev.map((s) =>
        s.column === columnId ? { ...s, direction: 'desc' } : s
      );
    }
    return prev.filter((s) => s.column !== columnId);
  });
};
```

## Pattern #3: Progressive Filtering

Layer filtering from simple to complex.

### Tier 1: Global Text Search

```tsx
export function SearchableTable<T>({ data, columns }: TableProps<T>) {
  const [searchTerm, setSearchTerm] = useState('');

  const filteredData = React.useMemo(() => {
    if (!searchTerm) return data;

    const lowerSearch = searchTerm.toLowerCase();
    return data.filter((row) =>
      columns.some((col) => {
        const value = row[col.id];
        return String(value).toLowerCase().includes(lowerSearch);
      })
    );
  }, [data, searchTerm, columns]);

  return (
    <>
      <input
        type="search"
        placeholder="Search across all columns..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        className="table-search"
      />
      <Table data={filteredData} columns={columns} />
    </>
  );
}
```

### Tier 2: Column-Specific Filters

```tsx
interface ColumnFilter {
  column: string;
  value: string;
  operator: 'contains' | 'equals' | 'startsWith' | 'gt' | 'lt';
}

export function AdvancedFilterTable<T>({ data, columns }: TableProps<T>) {
  const [filters, setFilters] = useState<ColumnFilter[]>([]);

  const filteredData = React.useMemo(() => {
    return data.filter((row) =>
      filters.every((filter) => {
        const cellValue = row[filter.column];
        const filterValue = filter.value;

        switch (filter.operator) {
          case 'contains':
            return String(cellValue).toLowerCase().includes(filterValue.toLowerCase());
          case 'equals':
            return cellValue === filterValue;
          case 'startsWith':
            return String(cellValue).toLowerCase().startsWith(filterValue.toLowerCase());
          case 'gt':
            return Number(cellValue) > Number(filterValue);
          case 'lt':
            return Number(cellValue) < Number(filterValue);
          default:
            return true;
        }
      })
    );
  }, [data, filters]);

  return (
    <>
      <FilterBuilder
        columns={columns}
        filters={filters}
        onChange={setFilters}
      />
      <Table data={filteredData} columns={columns} />
    </>
  );
}
```

### Tier 3: AI-Assisted Natural Language Filters

```tsx
export function AIFilterTable<T>({ data, columns }: TableProps<T>) {
  const [naturalQuery, setNaturalQuery] = useState('');

  const applyAIFilter = async () => {
    // Convert natural language to filters
    const filters = await ai.parseFilterQuery(naturalQuery, columns);
    setFilters(filters);
  };

  return (
    <>
      <div className="ai-filter">
        <input
          type="text"
          placeholder="e.g., 'Show me sales over $1000 from last month'"
          value={naturalQuery}
          onChange={(e) => setNaturalQuery(e.target.value)}
        />
        <button onClick={applyAIFilter}>Apply AI Filter</button>
      </div>
      <Table data={filteredData} columns={columns} />
    </>
  );
}

// AI parsing example
async function parseFilterQuery(query: string, columns: Column[]): Promise<ColumnFilter[]> {
  const prompt = `
    Parse this natural language query into structured filters:
    Query: "${query}"
    Available columns: ${columns.map(c => c.id).join(', ')}

    Return JSON array of filters with format:
    [{ "column": "amount", "operator": "gt", "value": "1000" }]
  `;

  const response = await ai.complete(prompt);
  return JSON.parse(response);
}
```

## Pattern #4: Efficient Row Selection

Handle single, multiple, and range selection.

```tsx
export function SelectableTable<T extends { id: string }>({
  data,
  columns,
}: TableProps<T>) {
  const [selected, setSelected] = useState<Set<string>>(new Set());
  const [lastSelected, setLastSelected] = useState<string | null>(null);

  const handleSelectRow = (rowId: string, shiftKey: boolean) => {
    if (shiftKey && lastSelected) {
      // Range selection
      const start = data.findIndex((r) => r.id === lastSelected);
      const end = data.findIndex((r) => r.id === rowId);
      const range = data.slice(
        Math.min(start, end),
        Math.max(start, end) + 1
      );

      setSelected((prev) => {
        const newSet = new Set(prev);
        range.forEach((row) => newSet.add(row.id));
        return newSet;
      });
    } else {
      // Toggle single row
      setSelected((prev) => {
        const newSet = new Set(prev);
        if (newSet.has(rowId)) {
          newSet.delete(rowId);
        } else {
          newSet.add(rowId);
        }
        return newSet;
      });
    }
    setLastSelected(rowId);
  };

  const handleSelectAll = () => {
    if (selected.size === data.length) {
      setSelected(new Set()); // Deselect all
    } else {
      setSelected(new Set(data.map((row) => row.id))); // Select all
    }
  };

  return (
    <table>
      <thead>
        <tr>
          <th>
            <input
              type="checkbox"
              checked={selected.size === data.length && data.length > 0}
              onChange={handleSelectAll}
              aria-label="Select all rows"
            />
          </th>
          {/* column headers */}
        </tr>
      </thead>
      <tbody>
        {data.map((row) => (
          <tr key={row.id} className={selected.has(row.id) ? 'selected' : ''}>
            <td>
              <input
                type="checkbox"
                checked={selected.has(row.id)}
                onChange={(e) => handleSelectRow(row.id, e.shiftKey)}
                aria-label={`Select row ${row.id}`}
              />
            </td>
            {/* row cells */}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

## Pattern #5: Responsive Table Design

Tables don't fit mobile screens. Use these strategies:

### Strategy 1: Horizontal Scroll with Sticky Columns

```css
.table-container {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

.table {
  width: 100%;
  min-width: 600px; /* Minimum table width */
}

.table th:first-child,
.table td:first-child {
  position: sticky;
  left: 0;
  background: var(--color-background-surface);
  z-index: 1;
}
```

### Strategy 2: Card Layout on Mobile

```tsx
export function ResponsiveTable<T>({ data, columns }: TableProps<T>) {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 640);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  if (isMobile) {
    return (
      <div className="table-cards">
        {data.map((row) => (
          <div key={row.id} className="table-card">
            {columns.map((col) => (
              <div key={col.id} className="card-row">
                <span className="card-label">{col.label}</span>
                <span className="card-value">{row[col.id]}</span>
              </div>
            ))}
          </div>
        ))}
      </div>
    );
  }

  return <Table data={data} columns={columns} />;
}
```

## Pattern #6: Pagination Strategies

Choose based on dataset size and use case.

### Page-Based Pagination

```tsx
export function PaginatedTable<T>({ data, columns, pageSize = 20 }: TableProps<T>) {
  const [currentPage, setCurrentPage] = useState(1);

  const totalPages = Math.ceil(data.length / pageSize);
  const startIndex = (currentPage - 1) * pageSize;
  const paginatedData = data.slice(startIndex, startIndex + pageSize);

  return (
    <>
      <Table data={paginatedData} columns={columns} />
      <div className="pagination">
        <button
          onClick={() => setCurrentPage((p) => Math.max(1, p - 1))}
          disabled={currentPage === 1}
        >
          Previous
        </button>
        <span>
          Page {currentPage} of {totalPages}
        </span>
        <button
          onClick={() => setCurrentPage((p) => Math.min(totalPages, p + 1))}
          disabled={currentPage === totalPages}
        >
          Next
        </button>
      </div>
    </>
  );
}
```

### Infinite Scroll

```tsx
export function InfiniteScrollTable<T>({ data, columns }: TableProps<T>) {
  const [visibleCount, setVisibleCount] = useState(50);
  const loadMoreRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && visibleCount < data.length) {
          setVisibleCount((prev) => Math.min(prev + 50, data.length));
        }
      },
      { threshold: 0.1 }
    );

    if (loadMoreRef.current) {
      observer.observe(loadMoreRef.current);
    }

    return () => observer.disconnect();
  }, [visibleCount, data.length]);

  const visibleData = data.slice(0, visibleCount);

  return (
    <>
      <Table data={visibleData} columns={columns} />
      {visibleCount < data.length && (
        <div ref={loadMoreRef} className="load-more">
          Loading more...
        </div>
      )}
    </>
  );
}
```

## Pattern #7: Inline Editing

Allow direct data manipulation without modals.

```tsx
export function EditableTable<T>({ data, columns, onUpdate }: TableProps<T>) {
  const [editingCell, setEditingCell] = useState<{ row: string; col: string } | null>(null);
  const [editValue, setEditValue] = useState('');

  const handleStartEdit = (rowId: string, colId: string, currentValue: any) => {
    setEditingCell({ row: rowId, col: colId });
    setEditValue(String(currentValue));
  };

  const handleSaveEdit = (rowId: string, colId: string) => {
    onUpdate(rowId, colId, editValue);
    setEditingCell(null);
  };

  return (
    <table>
      <tbody>
        {data.map((row) => (
          <tr key={row.id}>
            {columns.map((col) => {
              const isEditing =
                editingCell?.row === row.id && editingCell?.col === col.id;

              return (
                <td key={col.id}>
                  {isEditing ? (
                    <input
                      type="text"
                      value={editValue}
                      onChange={(e) => setEditValue(e.target.value)}
                      onBlur={() => handleSaveEdit(row.id, col.id)}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') handleSaveEdit(row.id, col.id);
                        if (e.key === 'Escape') setEditingCell(null);
                      }}
                      autoFocus
                    />
                  ) : (
                    <span onDoubleClick={() => handleStartEdit(row.id, col.id, row[col.id])}>
                      {row[col.id]}
                    </span>
                  )}
                </td>
              );
            })}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

## Design Token Integration

```css
:root {
  /* Table tokens */
  --table-border-color: var(--color-border-default);
  --table-header-bg: var(--color-background-surface);
  --table-row-hover: var(--color-background-hover);
  --table-row-selected: var(--color-primary-background);
  --table-cell-padding: var(--spacing-3);
  --table-header-font-weight: 600;
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table th {
  background: var(--table-header-bg);
  padding: var(--table-cell-padding);
  font-weight: var(--table-header-font-weight);
  border-bottom: 2px solid var(--table-border-color);
}

.table td {
  padding: var(--table-cell-padding);
  border-bottom: 1px solid var(--table-border-color);
}

.table tr:hover {
  background: var(--table-row-hover);
}

.table tr.selected {
  background: var(--table-row-selected);
}
```

## Common Data Table Mistakes

1. **No virtualization for large datasets** — Kills performance above 1000 rows
2. **Missing loading states** — Users need feedback during async operations
3. **Poor mobile experience** — Tables need responsive strategies
4. **No keyboard navigation** — Arrow keys, Tab, Enter should work
5. **Unclear sort state** — Users must know what's sorted
6. **Forgetting empty states** — "No results found" needs design
7. **No bulk actions** — Multi-select without actions is useless

## FramingUI Data Table System

FramingUI provides production-ready data tables:
- Built-in virtualization for 10,000+ rows
- AI-powered filtering and search
- Responsive mobile layouts
- Full keyboard navigation
- [Explore data table examples →](/explore)

## Related Resources

- [Form Validation UI Patterns](/blog/form-validation-ui-patterns) — Inline editing validation
- [Design Tokens Best Practices](/blog/design-tokens-best-practices) — Token-based table styling
- [Responsive Design Tokens](/blog/responsive-design-tokens) — Mobile table strategies

---

**Build data tables users love.** Performance, usability, and accessibility—FramingUI handles it all.
